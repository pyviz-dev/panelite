{"version":3,"file":"6176.31ecd8e.js","mappings":"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","sources":["webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@pyviz/jupyterlab_pyviz/node_modules/@jupyterlab/statedb/lib/dataconnector.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@pyviz/jupyterlab_pyviz/node_modules/@jupyterlab/statedb/lib/index.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@pyviz/jupyterlab_pyviz/node_modules/@jupyterlab/statedb/lib/restorablepool.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@pyviz/jupyterlab_pyviz/node_modules/@jupyterlab/statedb/lib/statedb.js","webpack://_JUPYTERLAB.CORE_OUTPUT/../node_modules/@pyviz/jupyterlab_pyviz/node_modules/@jupyterlab/statedb/lib/tokens.js"],"sourcesContent":["\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * An abstract class that adheres to the data connector interface.\n *\n * @typeparam T - The basic entity response type a service's connector.\n *\n * @typeparam U - The basic entity request type, which is conventionally the\n * same as the response type but may be different if a service's implementation\n * requires input data to be different from output responses. Defaults to `T`.\n *\n * @typeparam V - The basic token applied to a request, conventionally a string\n * ID or filter, but may be set to a different type when an implementation\n * requires it. Defaults to `string`.\n *\n * @typeparam W - The type of the optional `query` parameter of the `list`\n * method. Defaults to `string`.\n *\n * #### Notes\n * The only abstract method in this class is the `fetch` method, which must be\n * reimplemented by all subclasses. The `remove` and `save` methods have a\n * default implementation that returns a promise that will always reject. This\n * class is a convenience superclass for connectors that only need to `fetch`.\n */\nclass DataConnector {\n    /**\n     * Retrieve the list of items available from the data connector.\n     *\n     * @param query - The optional query filter to apply to the connector request.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can list.\n     */\n    async list(query) {\n        throw new Error('DataConnector#list method has not been implemented.');\n    }\n    /**\n     * Remove a value using the data connector.\n     *\n     * @param id - The identifier for the data being removed.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can remove.\n     */\n    async remove(id) {\n        throw new Error('DataConnector#remove method has not been implemented.');\n    }\n    /**\n     * Save a value using the data connector.\n     *\n     * @param id - The identifier for the data being saved.\n     *\n     * @param value - The data being saved.\n     *\n     * @returns A promise that always rejects with an error.\n     *\n     * #### Notes\n     * Subclasses should reimplement if they support a back-end that can save.\n     */\n    async save(id, value) {\n        throw new Error('DataConnector#save method has not been implemented.');\n    }\n}\nexports.DataConnector = DataConnector;\n//# sourceMappingURL=dataconnector.js.map","\"use strict\";\n/* -----------------------------------------------------------------------------\n| Copyright (c) Jupyter Development Team.\n| Distributed under the terms of the Modified BSD License.\n|----------------------------------------------------------------------------*/\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(require(\"./dataconnector\"));\n__export(require(\"./restorablepool\"));\n__export(require(\"./statedb\"));\n__export(require(\"./tokens\"));\n//# sourceMappingURL=index.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst coreutils_1 = require(\"@lumino/coreutils\");\nconst properties_1 = require(\"@lumino/properties\");\nconst signaling_1 = require(\"@lumino/signaling\");\n/**\n * An object pool that supports restoration.\n *\n * @typeparam T - The type of object being tracked.\n */\nclass RestorablePool {\n    /**\n     * Create a new restorable pool.\n     *\n     * @param options - The instantiation options for a restorable pool.\n     */\n    constructor(options) {\n        this._added = new signaling_1.Signal(this);\n        this._current = null;\n        this._currentChanged = new signaling_1.Signal(this);\n        this._hasRestored = false;\n        this._isDisposed = false;\n        this._objects = new Set();\n        this._restore = null;\n        this._restored = new coreutils_1.PromiseDelegate();\n        this._updated = new signaling_1.Signal(this);\n        this.namespace = options.namespace;\n    }\n    /**\n     * A signal emitted when an object object is added.\n     *\n     * #### Notes\n     * This signal will only fire when an object is added to the pool.\n     * It will not fire if an object injected into the pool.\n     */\n    get added() {\n        return this._added;\n    }\n    /**\n     * The current object.\n     *\n     * #### Notes\n     * The restorable pool does not set `current`. It is intended for client use.\n     *\n     * If `current` is set to an object that does not exist in the pool, it is a\n     * no-op.\n     */\n    get current() {\n        return this._current;\n    }\n    set current(obj) {\n        if (this._current === obj) {\n            return;\n        }\n        if (obj !== null && this._objects.has(obj)) {\n            this._current = obj;\n            this._currentChanged.emit(this._current);\n        }\n    }\n    /**\n     * A signal emitted when the current widget changes.\n     */\n    get currentChanged() {\n        return this._currentChanged;\n    }\n    /**\n     * Test whether the pool is disposed.\n     */\n    get isDisposed() {\n        return this._isDisposed;\n    }\n    /**\n     * A promise resolved when the restorable pool has been restored.\n     */\n    get restored() {\n        return this._restored.promise;\n    }\n    /**\n     * The number of objects held by the pool.\n     */\n    get size() {\n        return this._objects.size;\n    }\n    /**\n     * A signal emitted when an object is updated.\n     */\n    get updated() {\n        return this._updated;\n    }\n    /**\n     * Add a new object to the pool.\n     *\n     * @param obj - The object object being added.\n     *\n     * #### Notes\n     * The object passed into the pool is added synchronously; its existence in\n     * the pool can be checked with the `has()` method. The promise this method\n     * returns resolves after the object has been added and saved to an underlying\n     * restoration connector, if one is available.\n     */\n    async add(obj) {\n        var _a, _b;\n        if (obj.isDisposed) {\n            const warning = 'A disposed object cannot be added.';\n            console.warn(warning, obj);\n            throw new Error(warning);\n        }\n        if (this._objects.has(obj)) {\n            const warning = 'This object already exists in the pool.';\n            console.warn(warning, obj);\n            throw new Error(warning);\n        }\n        this._objects.add(obj);\n        obj.disposed.connect(this._onInstanceDisposed, this);\n        if (Private.injectedProperty.get(obj)) {\n            return;\n        }\n        if (this._restore) {\n            const { connector } = this._restore;\n            const objName = this._restore.name(obj);\n            if (objName) {\n                const name = `${this.namespace}:${objName}`;\n                const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);\n                Private.nameProperty.set(obj, name);\n                await connector.save(name, { data });\n            }\n        }\n        // Emit the added signal.\n        this._added.emit(obj);\n    }\n    /**\n     * Dispose of the resources held by the pool.\n     *\n     * #### Notes\n     * Disposing a pool does not affect the underlying data in the data connector,\n     * it simply disposes the client-side pool without making any connector calls.\n     */\n    dispose() {\n        if (this.isDisposed) {\n            return;\n        }\n        this._current = null;\n        this._isDisposed = true;\n        this._objects.clear();\n        signaling_1.Signal.clearData(this);\n    }\n    /**\n     * Find the first object in the pool that satisfies a filter function.\n     *\n     * @param - fn The filter function to call on each object.\n     */\n    find(fn) {\n        const values = this._objects.values();\n        for (const value of values) {\n            if (fn(value)) {\n                return value;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Iterate through each object in the pool.\n     *\n     * @param fn - The function to call on each object.\n     */\n    forEach(fn) {\n        this._objects.forEach(fn);\n    }\n    /**\n     * Filter the objects in the pool based on a predicate.\n     *\n     * @param fn - The function by which to filter.\n     */\n    filter(fn) {\n        const filtered = [];\n        this.forEach(obj => {\n            if (fn(obj)) {\n                filtered.push(obj);\n            }\n        });\n        return filtered;\n    }\n    /**\n     * Inject an object into the restorable pool without the pool handling its\n     * restoration lifecycle.\n     *\n     * @param obj - The object to inject into the pool.\n     */\n    inject(obj) {\n        Private.injectedProperty.set(obj, true);\n        return this.add(obj);\n    }\n    /**\n     * Check if this pool has the specified object.\n     *\n     * @param obj - The object whose existence is being checked.\n     */\n    has(obj) {\n        return this._objects.has(obj);\n    }\n    /**\n     * Restore the objects in this pool's namespace.\n     *\n     * @param options - The configuration options that describe restoration.\n     *\n     * @returns A promise that resolves when restoration has completed.\n     *\n     * #### Notes\n     * This function should almost never be invoked by client code. Its primary\n     * use case is to be invoked by a layout restorer plugin that handles\n     * multiple restorable pools and, when ready, asks them each to restore their\n     * respective objects.\n     */\n    async restore(options) {\n        if (this._hasRestored) {\n            throw new Error('This pool has already been restored.');\n        }\n        this._hasRestored = true;\n        const { command, connector, registry, when } = options;\n        const namespace = this.namespace;\n        const promises = when\n            ? [connector.list(namespace)].concat(when)\n            : [connector.list(namespace)];\n        this._restore = options;\n        const [saved] = await Promise.all(promises);\n        const values = await Promise.all(saved.ids.map(async (id, index) => {\n            const value = saved.values[index];\n            const args = value && value.data;\n            if (args === undefined) {\n                return connector.remove(id);\n            }\n            // Execute the command and if it fails, delete the state restore data.\n            return registry\n                .execute(command, args)\n                .catch(() => connector.remove(id));\n        }));\n        this._restored.resolve();\n        return values;\n    }\n    /**\n     * Save the restore data for a given object.\n     *\n     * @param obj - The object being saved.\n     */\n    async save(obj) {\n        var _a, _b;\n        const injected = Private.injectedProperty.get(obj);\n        if (!this._restore || !this.has(obj) || injected) {\n            return;\n        }\n        const { connector } = this._restore;\n        const objName = this._restore.name(obj);\n        const oldName = Private.nameProperty.get(obj);\n        const newName = objName ? `${this.namespace}:${objName}` : '';\n        if (oldName && oldName !== newName) {\n            await connector.remove(oldName);\n        }\n        // Set the name property irrespective of whether the new name is null.\n        Private.nameProperty.set(obj, newName);\n        if (newName) {\n            const data = (_b = (_a = this._restore).args) === null || _b === void 0 ? void 0 : _b.call(_a, obj);\n            await connector.save(newName, { data });\n        }\n        if (oldName !== newName) {\n            this._updated.emit(obj);\n        }\n    }\n    /**\n     * Clean up after disposed objects.\n     */\n    _onInstanceDisposed(obj) {\n        this._objects.delete(obj);\n        if (obj === this._current) {\n            this._current = null;\n            this._currentChanged.emit(this._current);\n        }\n        if (Private.injectedProperty.get(obj)) {\n            return;\n        }\n        if (!this._restore) {\n            return;\n        }\n        const { connector } = this._restore;\n        const name = Private.nameProperty.get(obj);\n        if (name) {\n            void connector.remove(name);\n        }\n    }\n}\nexports.RestorablePool = RestorablePool;\n/*\n * A namespace for private data.\n */\nvar Private;\n(function (Private) {\n    /**\n     * An attached property to indicate whether an object has been injected.\n     */\n    Private.injectedProperty = new properties_1.AttachedProperty({\n        name: 'injected',\n        create: () => false\n    });\n    /**\n     * An attached property for an object's ID.\n     */\n    Private.nameProperty = new properties_1.AttachedProperty({\n        name: 'name',\n        create: () => ''\n    });\n})(Private || (Private = {}));\n//# sourceMappingURL=restorablepool.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst signaling_1 = require(\"@lumino/signaling\");\n/**\n * The default concrete implementation of a state database.\n */\nclass StateDB {\n    /**\n     * Create a new state database.\n     *\n     * @param options - The instantiation options for a state database.\n     */\n    constructor(options = {}) {\n        this._changed = new signaling_1.Signal(this);\n        const { connector, transform } = options;\n        this._connector = connector || new StateDB.Connector();\n        if (!transform) {\n            this._ready = Promise.resolve(undefined);\n        }\n        else {\n            this._ready = transform.then(transformation => {\n                const { contents, type } = transformation;\n                switch (type) {\n                    case 'cancel':\n                        return;\n                    case 'clear':\n                        return this._clear();\n                    case 'merge':\n                        return this._merge(contents || {});\n                    case 'overwrite':\n                        return this._overwrite(contents || {});\n                    default:\n                        return;\n                }\n            });\n        }\n    }\n    /**\n     * A signal that emits the change type any time a value changes.\n     */\n    get changed() {\n        return this._changed;\n    }\n    /**\n     * Clear the entire database.\n     */\n    async clear() {\n        await this._ready;\n        await this._clear();\n    }\n    /**\n     * Retrieve a saved bundle from the database.\n     *\n     * @param id - The identifier used to retrieve a data bundle.\n     *\n     * @returns A promise that bears a data payload if available.\n     *\n     * #### Notes\n     * The `id` values of stored items in the state database are formatted:\n     * `'namespace:identifier'`, which is the same convention that command\n     * identifiers in JupyterLab use as well. While this is not a technical\n     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n     * using the `list(namespace: string)` method.\n     *\n     * The promise returned by this method may be rejected if an error occurs in\n     * retrieving the data. Non-existence of an `id` will succeed with the `value`\n     * `undefined`.\n     */\n    async fetch(id) {\n        await this._ready;\n        return this._fetch(id);\n    }\n    /**\n     * Retrieve all the saved bundles for a namespace.\n     *\n     * @param filter - The namespace prefix to retrieve.\n     *\n     * @returns A promise that bears a collection of payloads for a namespace.\n     *\n     * #### Notes\n     * Namespaces are entirely conventional entities. The `id` values of stored\n     * items in the state database are formatted: `'namespace:identifier'`, which\n     * is the same convention that command identifiers in JupyterLab use as well.\n     *\n     * If there are any errors in retrieving the data, they will be logged to the\n     * console in order to optimistically return any extant data without failing.\n     * This promise will always succeed.\n     */\n    async list(namespace) {\n        await this._ready;\n        return this._list(namespace);\n    }\n    /**\n     * Remove a value from the database.\n     *\n     * @param id - The identifier for the data being removed.\n     *\n     * @returns A promise that is rejected if remove fails and succeeds otherwise.\n     */\n    async remove(id) {\n        await this._ready;\n        await this._remove(id);\n        this._changed.emit({ id, type: 'remove' });\n    }\n    /**\n     * Save a value in the database.\n     *\n     * @param id - The identifier for the data being saved.\n     *\n     * @param value - The data being saved.\n     *\n     * @returns A promise that is rejected if saving fails and succeeds otherwise.\n     *\n     * #### Notes\n     * The `id` values of stored items in the state database are formatted:\n     * `'namespace:identifier'`, which is the same convention that command\n     * identifiers in JupyterLab use as well. While this is not a technical\n     * requirement for `fetch()`, `remove()`, and `save()`, it *is* necessary for\n     * using the `list(namespace: string)` method.\n     */\n    async save(id, value) {\n        await this._ready;\n        await this._save(id, value);\n        this._changed.emit({ id, type: 'save' });\n    }\n    /**\n     * Return a serialized copy of the state database's entire contents.\n     *\n     * @returns A promise that resolves with the database contents as JSON.\n     */\n    async toJSON() {\n        await this._ready;\n        const { ids, values } = await this._list();\n        return values.reduce((acc, val, idx) => {\n            acc[ids[idx]] = val;\n            return acc;\n        }, {});\n    }\n    /**\n     * Clear the entire database.\n     */\n    async _clear() {\n        await Promise.all((await this._list()).ids.map(id => this._remove(id)));\n    }\n    /**\n     * Fetch a value from the database.\n     */\n    async _fetch(id) {\n        const value = await this._connector.fetch(id);\n        if (value) {\n            return JSON.parse(value).v;\n        }\n    }\n    /**\n     * Fetch a list from the database.\n     */\n    async _list(namespace = '') {\n        const { ids, values } = await this._connector.list(namespace);\n        return {\n            ids,\n            values: values.map(val => JSON.parse(val).v)\n        };\n    }\n    /**\n     * Merge data into the state database.\n     */\n    async _merge(contents) {\n        await Promise.all(Object.keys(contents).map(key => contents[key] && this._save(key, contents[key])));\n    }\n    /**\n     * Overwrite the entire database with new contents.\n     */\n    async _overwrite(contents) {\n        await this._clear();\n        await this._merge(contents);\n    }\n    /**\n     * Remove a key in the database.\n     */\n    async _remove(id) {\n        return this._connector.remove(id);\n    }\n    /**\n     * Save a key and its value in the database.\n     */\n    async _save(id, value) {\n        return this._connector.save(id, JSON.stringify({ v: value }));\n    }\n}\nexports.StateDB = StateDB;\n/**\n * A namespace for StateDB statics.\n */\n(function (StateDB) {\n    /**\n     * An in-memory string key/value data connector.\n     */\n    class Connector {\n        constructor() {\n            this._storage = {};\n        }\n        /**\n         * Retrieve an item from the data connector.\n         */\n        async fetch(id) {\n            return this._storage[id];\n        }\n        /**\n         * Retrieve the list of items available from the data connector.\n         *\n         * @param namespace - If not empty, only keys whose first token before `:`\n         * exactly match `namespace` will be returned, e.g. `foo` in `foo:bar`.\n         */\n        async list(namespace = '') {\n            return Object.keys(this._storage).reduce((acc, val) => {\n                if (namespace === '' ? true : namespace === val.split(':')[0]) {\n                    acc.ids.push(val);\n                    acc.values.push(this._storage[val]);\n                }\n                return acc;\n            }, { ids: [], values: [] });\n        }\n        /**\n         * Remove a value using the data connector.\n         */\n        async remove(id) {\n            delete this._storage[id];\n        }\n        /**\n         * Save a value using the data connector.\n         */\n        async save(id, value) {\n            this._storage[id] = value;\n        }\n    }\n    StateDB.Connector = Connector;\n})(StateDB = exports.StateDB || (exports.StateDB = {}));\n//# sourceMappingURL=statedb.js.map","\"use strict\";\n// Copyright (c) Jupyter Development Team.\n// Distributed under the terms of the Modified BSD License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst coreutils_1 = require(\"@lumino/coreutils\");\n/* tslint:disable */\n/**\n * The default state database token.\n */\nexports.IStateDB = new coreutils_1.Token('@jupyterlab/coreutils:IStateDB');\n//# sourceMappingURL=tokens.js.map"],"names":["Object","defineProperty","exports","value","DataConnector","async","query","Error","id","__export","m","p","hasOwnProperty","coreutils_1","properties_1","signaling_1","Private","RestorablePool","constructor","options","this","_added","Signal","_current","_currentChanged","_hasRestored","_isDisposed","_objects","Set","_restore","_restored","PromiseDelegate","_updated","namespace","added","current","obj","has","emit","currentChanged","isDisposed","restored","promise","size","updated","_a","_b","warning","console","warn","add","disposed","connect","_onInstanceDisposed","injectedProperty","get","connector","objName","name","data","args","call","nameProperty","set","save","dispose","clear","clearData","find","fn","values","forEach","filter","filtered","push","inject","command","registry","when","promises","list","concat","saved","Promise","all","ids","map","index","undefined","remove","execute","catch","resolve","injected","oldName","newName","delete","AttachedProperty","create","StateDB","_changed","transform","_connector","Connector","_ready","then","transformation","contents","type","_clear","_merge","_overwrite","changed","_fetch","_list","_remove","_save","reduce","acc","val","idx","fetch","JSON","parse","v","keys","key","stringify","_storage","split","IStateDB","Token"],"sourceRoot":""}